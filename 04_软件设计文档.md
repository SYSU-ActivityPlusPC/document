# 软件设计文档
**小组成员：肖雨蓓，唐玄昭，吴雪敏，朱理锋，李佳仕**

## 总体设计 预备
### 设计流程--从关键模型一步步设计 预备

用例图/DomainModel图/ER图/架构图

### 总体架构

总体上使用了MVC的软件架构模式和RESTful架构风格，同时为了降低耦合以及减少编码工作之间的相互牵制，我们的项目使用了前后端分离的思想，前后端通过遵循API的设计分别进行工作，因此只需要保证API文档的准确性和实时更新，那么前端和后端便能够相互独立地进行编码工作，从而有效地促进工作效率。

![总体架构](./picture/Design/1.png)

客户通过与前端页面进行交互，前端根据用户的操作通过ajax技术异步发送HTTP请求给后端，后端接收请求后，通过路由分发到不同的controller进行处理，ORM框架将后端对象与数据库关系进行一一映射，后端controller操作model进行数据的改变，请求经过处理后，后端最后生成响应发送给前端，前端得到HTTP响应后，通过解析和浏览器渲染，将结果呈现给用户。

![MVC](./picture/Design/2.png)

在这整个过程中后端给前端提供RESTful接口服务，而在后端controller和数据库model之间，我们使用了ORM框架（对象关系映射框架），从而简化了对数据库进行的增删改查等等操作，让我们可以以处理对象的方式来间接操作数据库。

其中在前端我们使用的是vue全家桶（vue + vue-router + iview ）+ axios + webpack技术栈，在后端我们使用的是nginx+golang技术栈，在Golang的许多开源包的辅助下实现了我们的RESTful API，同时我们使用了MySQL数据库。

由于我们采用了前后端分离的思想，因此我们将项目划分为了两个子仓库：service-end和front-end，让前端和后端工程师分别管理自己的项目，进行开发工作。因此，我们接下来分别从前端和后端方面介绍技术选型，架构设计，模块划分以及使用到的软件设计技术。


## 前端
### 技术选型及理由

本项目前端的技术栈为vue全家桶（vue + vue-router + iview ）+ axios + webpack

- vue： 当下最火最容易上手的MVVM框架
- vue-router: 前端路由
- axios：很强大很好上手的ajax请求库
- ivew: 一款vue的ui框架，精美好看
- webpack：打包工具

**选择这些技术的理由：**

**vue：**

vue是国人开发的一款MVVM框架。它的特点是轻量 ，好上手 。考虑到前端开发同学的技术栈参差不齐，所以统一选用vue来作为开发框架，因为它好上手，学习的曲线是很平滑的，不像react和angular这类MVVM框架学习成本较高。其次就是轻量，vue的作者给广大开发者提供了一个脚手架工具，能够一键生成项目，生成的项目里有vuex，有vue-router，也有eslint这类工具，做到了开箱即用。对比react，react的比较出名的脚手架工具没有vue-cli这么方便，它还得自己根据需求去添加别的第三方插件，而且添加的成本略高，需要去看英文文档和写一些引入代码。综合对比react和angular在这两点上的不同，最后选择了vue。



**vue-router：**

vue-router是配套vue的一个单页面路由的插件。单页面与传统的网页最大不一样的地方就是，传统网页的路由是有后台去控制的，而单页面网页的路由是放在前台的，在前台中控制。故vue-router是必选的



**axios：**

选用的原因很简单，就是简单和强大。简单在于可以一行代码就发起一个http请求，支持promise，所以也就可以使用async await来以同步的形式写异步的代码。

强大在于提供了拦截器等功能。方便我们在发起请求前在header增加token，以及在收到回复中，分析结果，统一处理错误。



**iview：**

一款相对其他vue的ui框架比较好的ui框架。而且还比较好看，故选用。



**webpack:**

webpack 是当下前端最流行的构建打包工具，利用 webpack 搭配相应的 loader，我们可以在前端项目中使用 es6 进行开发，效率更高。开发完成后，webpack 还可以帮我们完成构建，将代码编译到 es5 以兼容大部分浏览器。webpack 优化了构建打包的算法，优化前端的模块加载，使得构建打包后的产品代码体积更小。


### 架构设计

前端项目主要是页面样式开发，交互逻辑开发以及开发完后的部署。可分为开发环境和生产环境。而开发环境和生产环境都需要webpack来构建。webpack构建首先需要源代码，其次webpack是配置大于约定的，需要我们写配置文件去告诉它从哪个入口文件开始打包，打包哪种文件，如何打包等等，打包后还会生成一个可用于我们部署到服务器的文件。另外，由于前后端现在是分离的。前后端开发环境不一样，肯定会出现跨域等情况，又或者开发时，热更新可以帮助我们减少重复的操作等等，所以又需要额外的配置文件。故综合以上的分析，我们需要以下4个包

- build：根据config和执行环境来打包构建src中的代码，使其可运行，可调试
- config：项目的webpack打包配置、http代理配置
- src: 源码，平时开发写的代码都在这里
- dist：项目打包后生成的可部署文件

![image](./picture/Design/3.png)


上面也说到我们的源码都在src里面。而一个可维护和可扩展的代码是需要做好文件架构的。根据单一职责原则，我们可以先把代码分割成 assets，router，utils，style和页面的UI和逻辑代码五个部分。

assets主要放一些资源，比如icon和图片。

router主要放前端的路由配置，这里指明了前端的页面的路由路径以及对应的组件。

style放了一些全局的样式和动画的样式，由于浏览器默认的标签样式不统一，为了让我们的网页在各个页面展示的效果一致，我们需要一个reset.css来统一标签的样式，也由于我们会用到一些比较好看的动画效果，有时候自己写比较麻烦，而已经有人做好了轮子，我们直接拿来用就是了，比如我们这次引用的animate.css。

utils就放了全局通用的方法，需要用到的话引入即可，不需要每个组件都写一份。

至于最后的页面UI和逻辑代码。我们这里采用了组件开发的思想，每个页面抽象为一个有很多组件组合而成的。我们需要把可复用的页面UI和逻辑抽象成为一个组件。那需要用到的页面直接使用就好。这样的思想，给我们带来了高复用，高内聚，低耦合的好处。故这部分又可以分为 components和pages两个部分。components就是可复用的组件。pages就是组装这些组件的代码。而且根据页面来命名文件，协作者一看到文件名就知道对应哪个页面，这样也提高了效率。

- components：可复用组件
- pages: 页面组件
- utils：公共工具函数
- style：公共样式、重置样式和动画样式
- assets：图标、图片等静态资源
- router：前端路由
  
![image](https://user-images.githubusercontent.com/23744602/42075706-c2bad318-7ba4-11e8-9b6f-f77483f0a1ea.png)

### 模块划分

根据设计图和应用的业务逻辑，我们可以得到以下界面关系图。根据每个界面的业务逻辑关联度和操作上的关联度，可以大致将应用的所有界面划分到4个模块中，如下图中蓝色框所标识出的模块，以及顶部红色框所示登录注册模块。

![界面关系图](./picture/logical_image.png)

按照界面划分好的情况，我们可以将组件包 components 细分为4大模块，将每个界面组件根据上面的划分情况放到相应的模块中进行管理。接着继续细分其他包，通用包可以划分为 style 和 utils，项目中有公共样式和公共工具函数，其他的公共内容几乎没有，因此这里只划分了两个模块（公共组件一般可以直接引用 UI 框架的组件）。router 只提供路由配置和控制功能，不需要再继续划分。

最后，综合考虑使用的技术框架，并根据应用需要的页面组件，我们可以完善得到详细的项目结构如下所示。后续的开发可以明确地进行分工，每个人负责不同的模块，然后进入到相应的包里面进行开发即可。顶层的模块如果需要修改配置或者更新内容，由项目负责人与成员商定后进行修改即可，做好顶层配置后，可以很好地解耦各模块，使得项目能够顺利、快速地完成开发。如果过需要新增界面、功能，引入新组件，也可以很方便地将新内容添加到项目中去。

```txt
├─build：存放构建用到的相关文件
├─config：存放配置文件
├─src：前端开发的源码
│   ├─assets：图片等静态资源
│   ├─common：公共样式或js文件
│   │    ├─css：字体和图标文件
│   │    │  ├─font.css：字体文件
│   │    │  └─icon.css：图标文件
│   │    ├─sass：公共样式文件
│   │    └─utils：公共工具函数库
│   │       ├─DateUtils.js：处理时间日期的工具函数
│   │       ├─Form.js：表单工具函数
│   │       └─LazyLoad.js：实现图片懒加载
│   ├─components：前端通用组件
│   │    ├─avatar：头像展示组件
│   │    ├─bigCard：浮层卡片组件
│   │    ├─breadcrumbNav：面包屑导航组件
│   │    ├─button：按钮组件
│   │    ├─footer：页面底栏组件
│   │    ├─header：页面顶栏组件
│   │    ├─listItem：列表项组件
│   │    ├─publishForm：发布活动表格组件
│   │    ├─selectForm：活动额外信息填充组件
│   │    ├─status：活动状态组件
│   │    └─steps：活动审核步骤组件
│   ├─pages：前端页面模块
│   │    ├─admin：管理员模块
│   │    |   ├─communityManage：社团管理
│   │    |   |    ├─application：社团注册审核
|   |    |   |    └─notice：社团通知
│   │    |   ├─dataManage：活动管理
│   │    |   |    ├─activityManage：审核通过活动列表
│   │    |   |    ├─activityReview：待审核活动列表
|   |    |   |    └─collection：活动推送模板生成
│   │    |   └─publish：活动发布
│   │    ├─community：社团模块
│   │    |   ├─activityManage：活动管理
│   │    |   ├─home：系统通知管理
│   │    |   └─publish：活动发布
│   │    ├─tourist：游客模块
│   │    |   └─publish：活动发布
│   │    ├─login：登录模块
│   │    └─regist：注册模块
│   ├─router：前端路由
│   │    └─index.js：前端路由信息配置文件
│   ├─style：应用的全局样式
│   │    ├─animate：动画样式
│   │    ├─common：全局通用样式
│   │    └─reset：整体元素样式重置
│   ├─utils：全局通用工具函数
│   │    ├─index：功能性函数
│   │    └─validate：表单输入验证函数
│   ├─App.vue：应用的最外层结构
│   └─main.js：应用的入口文件；第三方组件和公共文件在此引入
└─docs：项目用到的文档，如后端接口文档
```

### 软件设计技术

* 面向对象编程：应用中使用了面向对象编程的封装思想，按照业务逻辑将代码的各个模块进行了封装，最明显的地方就是 router 和 utils。router 封装了路由配置信息，在界面的业务逻辑代码中通过 $router 对象可以控制界面跳转，通过$route对象可以实现路由间信息传递。而 utils 则是封装了公共工具函数。代码对应的模块分别为 router、utils。
* 代理模式：前端所访问的服务器是一个 NodeJS 服务器，但我们的 API 却都是 Go 服务器所提供。在这里，为了便于本地的调试，我们用NodeJS 服务器做了一层中间代理，使得前端可以访问到 Go 服务器的 API。但前端并不知道 Go 服务器的存在。由于这层中间代理的存在，使得前端无需考虑跨域问题就能调用后台 Go 服务器的接口。对应的代码为 build/dev-server.js 和 config/index.js。
* 发布订阅模式：应用的数据变化会自动影响到引用了该数据的界面，促使界面发生更新，主要使用的设计模式即发布订阅模式。这部分由 Vue 框架本身实现。

## 后端
### 技术选型及理由

后端的技术栈为nginx+golang+mysql+gorilla/mux+xorm
golang是一门编程语言，其内置了web支持，其优势在于性能高，学习周期短，开发成本低，专一化，轻量化，考虑到各种语言的熟悉程度和部署成本，我们决定使用golang作为我们的后台开发语言

Nginx 是一个高性能的负载均衡服务器，支持负载均衡；能够快速灵活且可靠的传送静态文件，同时能保证网站在面对恶意流量的攻击中能正常运行，从而保护应用安全。该项目使用nginx作为反向代理工具，使得后台的编码无需考虑繁复的路径问题，同时提供给后台良好的可扩展性。

MySQL 是目前最流行的关系型数据库管理系统，被广泛地应用在 Internet 上的中小型网站中，它具有体积小、速度快、总体拥有成本低，且其免费开源。此次开发使用关系型数据库作为用户信息和活动信息的存储载体。

gorilla/mux 是一个强大的路由，小巧但是稳定高效，不仅可以支持正则路由还可以按照Method，header，host等信息匹配，可以从我们设定的路由表达式中提取出参数方便上层应用，而且完全兼容http.ServerMux。从而可以较好地实现RESTful API服务，因此选择了它。

xorm 是一个简单而强大的Go语言ORM库，通过它可以使数据库操作非常简便， 因此与数据库交互的部分我们使用了xorm。

### 架构设计 预备

后端架构设计主要包括后端架构设计和后端框架应用，其中后端框架的选择在技术选型及理由中已经列出，因此在这里，我们将结合我们项目的实际描述一下我们的架构：

我们使用的架构模式是经典的三层架构：表示层，业务层和持久化层，因为这种架构使得工作模块化并可扩展，能够降低耦合性，提高代码可重用性，同时支持并行开发，因此使得开发工作效率极大地提高了。

``` txt
- 表示层（Presentation Layer）
    - Models，Views，Controllers
    - State Management
- 业务层（Business Layer）/服务层（Service Layer）
    - Transacton（交易）
    - Query（查询）
- 持久化层（Persistent Layer）/ 数据访问层（Data Access     Layer/DAO）
    - CRUD（实体的四种操作）
    - ORM（实体与关系映射）
```

![后端架构图](./picture/Design/4.png)

我们主要基于 **低耦合**，**高内聚**， **防止变异** 等基本的架构设计原则进行了我们的分层设计。我们是在软件的一次次迭代中，使用GRASP进行基于职责的对象设计，一次次迭代对上一次的结果进行优化改进。

在后端的内部类组织中，我们使用了BCE模型：

```txt
Boundary：与外部 Actor 交互的类。包括 UI、外部系统接口
Controller：处理外部事件，实现控制流的类。通常是一个子系统、一个用例一个类
Entity：领域对象或数据实体
```

以下是从逻辑设计类图映射到我们实际项目框架的包图：

![逻辑设计类图->包图]()

其次在我们的项目中，API设计和数据库设计主要由后端进行设计决定，因此在后面进行说明。

#### 数据库设计

我们在总体架构中，一步一步从领域模型设计到ER图，其实就已经得到了我们的数据库表和之间的关系，下面是我们最终的数据库图：

![数据库图](./picture/Design/er_diagram.png)

对于社团用户和管理员，我们直接通过pcuser的name和id进行区分，因为我们规定仅有一个管理员账户，因此没有必要为管理员账号新开一张表，同时我们将pcuser与activity设置为1对多的关系，符合现实意义即一个用户可以发布多个活动。我们使用了message_pcuser来存储pcuser和message的id对，因为message和pcuser是多对多的关系，一个消息可以被发送给多个用户，一个用户也可以接收多个不同的消息。

因此，以上数据库是合理且符合现实意义的。


#### API设计

我们的API设计是遵循RESTful API的风格，并且使用apiary.io平台实现API的共享协作和测试，我们根据API处理的资源不同对其进行了模块的划分：
- ActApply模块
- Message模块
- Session模块
- PCUser模块
- Picture模块
- Activity模块

API模块截图如下：

![API模块截图](./picture/Design/5.png)

以Session模块接口为例，如下图，每个接口的参数以及类型说明都一目了然，接口中未说明清晰的地方还会在每次迭代中用技术文档说明，大大提高了开发和前后端对接效率。 

![SessionAPI](./picture/Design/6.png)

### 模块划分 预备
组件包图...模块之间相关关联图...

后端开发主要包括API的开发以及权限访问控制等功能的实现，因此我们后端可以划分为路由器模块，API模块(controller)，数据模块(model)，中间件模块，类型处理模块；其中API模块根据各个接口的功能又可以划分为活动报名模块(actapply)，消息模块(message)，session模块，用户模块(pcuser)，图片模块(picture)，活动模块(activity)，因此可以看到模块划分十分清晰，便于管理和工作。

服务端目录结构如下：

![服务端目录]()


### 软件设计技术 唐玄昭

**OOP**：使用golang作为后台语言，利用领域模型建模，将需要用到的实体使用类的方式进行封装，并给予相应的属性和方法，以数据库对象Activity为例：

![属性值](picture/sdd-1.png)
![方法](picture/sdd-2.png)

以上两张图分别包含了Activity这么一个类所具有的属性值和方法，外部可以通过调用方法来实现对数据库的修改

**3-tier architecture**：考虑到扩展性和可维护性，我们将后台分成表示层-业务逻辑层-持久化层，分别负责请求信息的读取及返回值的封装、业务逻辑的处理、数据库等持久化对象的处理，三者各司其职，每一层只对上一层提供服务，同样的，每一层也只能调用其下一层的服务，从而降低了系统的耦合性；而业务逻辑层基本上只会使用一个数据库对象，因此达到了高内聚的要求；

![architecture](picture/sdd-4.png)

对于后台系统来说，系统不关心用户之前访问了什么，所有的请求信息都包括在了当前的请求之内，从而为系统的可扩展性带来了方便，从compose文件可以看到，后台系统之前存在一个nginx网关，负责请求的分发和静态文件的代理，因此考虑扩展性方面，只需要简单地多创建几个服务端容器实例即可，无需关注其他问题

![compose](picture/sdd-3.png)

**要给出其在源代码中出现的位置，指明对应模块和代码**
